---
title: "temporary Vernalization 04 file"
author: "XinYu Zhang"
date: "2023-11-08"
output: html_document
---



Exercise 1. Loading the dataset (raw_data)
```{r}
raw_data<-read.csv("~/Desktop/raw_counts.csv.gz")
```


Exercise 3.Fix the column names by removing "." because “.” is a wildcard character.
```{r}
library(stringr)
colnames(raw_data) <- str_remove(colnames(raw_data), fixed("."))
colnames(raw_data)
```


Exercise 4.Make a histogram of counts for each of the samples
Conclusion: the data is not normally distributed
```{r}
library(tidyr)
library(ggplot2)
library(dplyr)
#change data into long format
raw_data_long_format <- raw_data %>% 
  pivot_longer(c(-geneID), names_to="sample", values_to="count")

#Make a histogram
ggplot(raw_data_long_format, aes(x = count)) +
  geom_histogram(bins = 10, fill = "blue", color = "black") +
  xlim(c(0, 1000)) + 
  theme_minimal() +
  labs(title = "Histogram of Counts within Specified Range", x = "Count", y = "Frequency")
#Conclusion: Non-normal distribution

```

```{r}
raw_data <- raw_data[rowSums(raw_data[,-1] > 10) >= 3,]#For our subsequent analyses we want to reduce the data set to only those genes with some expression. In this case we will retain genes with > 10 reads in >= 3 samples
```

Exercise 5.check for correlation and visualize it
```{r}
library(tidyr)
library(dplyr)
library(gplots)
library(viridis)
library(stringr)

raw_data_limited <- raw_data[1:1000, -which(colnames(raw_data) == "geneID")]
# Adjust margins: c(bottom, left, top, right)
par(mar=c(4, 4, 2, 2))
#pairs(raw_data_limited) Large gra
raw_data_cor_table <- cor(raw_data_limited, use = "complete.obs")
print(raw_data_cor_table)#correlation table



raw_data_cor_table %>% gplots::heatmap.2(dendrogram="row", trace = "none", col=viridis::viridis(25, begin=.25), margins=c(7,8))
```


Exercise 6.Data Normalization
```{r}
sample.description_raw_data <-tibble(sample=colnames(raw_data)[-1])

data <- sample.description_raw_data%>% mutate(
    Pop = str_extract(sample,"bhr|ihl|kc|lv|sq|tm|wl|yo"), Vern = str_extract(sample, "v0|v1|v2|i0|i1|i2"),
    group = str_c(Vern, Pop, sep = "_"))
print(head(data))

#convert Elevation and Vernalization into factors for testing No vern,short vern, and long vern

sample.description_data <- data%>%
  mutate(Pop=factor(Pop), 
         Vern=factor(Vern,levels = c("v0","v1", "v2","i0","i1","i2"))) # setting the levels in this way makes "v0" the reference  

sample.description_data
```


Exercise 6. Normalization factor and plot
```{r}
#calculate the effective library size and normalization factors using the TMM method
library(edgeR)

counts.matrix_raw_data <- raw_data %>% select(-geneID) %>% as.matrix()
rownames(counts.matrix_raw_data) <- raw_data$geneID

dge.data_Normalization <- DGEList(counts=counts.matrix_raw_data, 
                    group=sample.description_raw_data$group)
dim(dge.data_Normalization) 
dge.data_Normalization <- calcNormFactors(dge.data_Normalization, method = "TMM")
dge.data_Normalization$sample # look at the normalization factors

plotMDS(dge.data_Normalization, method = "bcv") 
```

```{r}
## make sure sample order is the same in the dge object and in the sample sheet
all(sample.description_data$sample==rownames(dge.data_Normalization$samples) )
```

subset bhr
```{r}
dge.data_Normalization.bhr <- dge.data_Normalization[,sample.description_data$Pop=="bhr"]
dge.data_Normalization.bhr$samples
```


Exercise 8
```{r}
data_Normalization<-cpm(dge.data_Normalization)
data_Normalization_log <- log2(data_Normalization[,-1]+1)

design <- model.matrix(~Pop+Vern,data = sample.description_data)
rownames(design) <- sample.description_data$sample
design


dge.data_Normalization_dispersions <- estimateGLMCommonDisp(dge.data_Normalization,design,verbose = TRUE)
dge.data_Normalization_dispersions <- estimateGLMTrendedDisp(dge.data_Normalization_dispersions,design)
dge.data_Normalization_dispersions <-estimateGLMTagwiseDisp(dge.data_Normalization_dispersions,design)
plotBCV(dge.data_Normalization_dispersions) 
```

```{r}
fit <- glmFit (dge.data_Normalization_dispersions,design)
gt.lrt <- glmLRT(fit,coef="Vernv1")
topTags(gt.lrt)
summary(decideTestsDGE(gt.lrt,p.value=0.01))
#Question: sicne logFC is the log2 fold-change in expression what does the vernv0 comparing to based on the logFC? v0?

```


subset bhr single comparsion v0 vs v1
```{r}
dge.data_Normalization.bhr <- dge.data_Normalization [,sample.description_data $Pop=="bhr"]
dge.data_Normalization.bhr$samples

sample.description_data.bhr <- sample.description_data %>%
  filter(Pop == "bhr")


design.bhr <- model.matrix(~Vern,data = sample.description_data.bhr)
rownames(design.bhr) <- sample.description_data.bhr$samples
design.bhr


dge.data_Normalization_dispersions.bhr <- estimateGLMCommonDisp(dge.data_Normalization.bhr,design.bhr,verbose = TRUE)

fit.bhr <- glmFit(dge.data_Normalization_dispersions.bhr,design.bhr)
gt.lrt.bhr <- glmLRT(fit.bhr,coef="Vernv1")
result_v0v1_bhr<-summary(decideTestsDGE(gt.lrt.bhr,p=0.01))
print(result_v0v1_bhr)
```


subset yo single comparsion 
```{r}
dge.data_Normalization.yo <- dge.data_Normalization [,sample.description_data $Pop=="yo"]
dge.data_Normalization.yo$samples

sample.description_data.yo <- sample.description_data %>%
  filter(Pop == "yo")
sample.description_data.yo

design.yo <- model.matrix(~Vern,data = sample.description_data.yo)
rownames(design.yo) <- sample.description_data.yo$samples
design.yo


dge.data_Normalization_dispersions.yo <- estimateGLMCommonDisp(dge.data_Normalization.yo,design.yo,verbose = TRUE)

fit.yo <- glmFit(dge.data_Normalization_dispersions.yo,design.yo)
gt.lrt.yo <- glmLRT(fit.yo,coef="Vernv1")
result_v0v1.yo<-summary(decideTestsDGE(gt.lrt.yo,p=0.01))

print(result_v0v1.yo)
```

Loop for each population (vo vs v1)


| Population | Down | NotSig | Up   |
|------------|------|--------|------|
| bhr        | 298  | 29088  | 597  |
| ihl        | 203  | 28977  | 803  |
| kc         | 282  | 28978  | 723  |
| lv         | 203  | 28458  | 1322 |
| sq         | 637  | 29302  | 44   |
| tm         | 1521 | 27924  | 538  |
| wl         | 112  | 29533  | 338  |
| yo         | 270  | 29373  | 340  |


```{r}
pop_groups <- unique(sample.description_data$Pop)
results_list <- list()

for (pop in pop_groups) {

  #Extract the Normalization data for each population
  dge.data_Normalization_pop <- dge.data_Normalization[, sample.description_data$Pop == pop]
  #Extract sample description data for each population
  sample.description_data_pop <- sample.description_data %>% filter(Pop == pop)
  #redesign the matrix with correct # column for each population
  design_pop <- model.matrix(~Vern, data = sample.description_data_pop)
  rownames(design_pop) <- sample.description_data_pop$samples
  #using matrix to find out the Normalization dispersions for each population
  dge.data_Normalization_dispersions_pop <- estimateGLMCommonDisp(dge.data_Normalization_pop, design_pop, verbose = TRUE)
  
  #Fit the model for each population dispersion data
  fit_pop <- glmFit(dge.data_Normalization_dispersions_pop, design_pop)
  # Conduct likelihood ratio test for each population
  gt.lrt_pop <- glmLRT(fit_pop, coef = "Vernv1")
  
  # Summarize the results for each population (up / down regulation)
  result_v0v1_pop <- summary(decideTestsDGE(gt.lrt_pop, p = 0.01))
  description <- "v0v1 comparison for population: " 
  results_list[[pop]] <- list(
  Description = paste(description, pop, sep=""),
  Results = result_v0v1_pop)
  }

# Print or return results
print(results_list)
```




Loop for each population (vo vs v2)


| Population | Down | NotSig | Up   |
|------------|------|--------|------|
| bhr        | 530  | 28489  | 964  |
| ihl        | 368  | 28630  | 985  |
| kc         | 105  | 29197  | 681  |
| lv         | 1081 | 27785  | 1117 |
| sq         | 707  | 29161  | 115  |
| tm         | 35   | 29708  | 240  |
| wl         | 223  | 29277  | 483  |
| yo         | 126  | 29297  | 560  |

```{r}
pop_groups <- unique(sample.description_data$Pop)
results_list <- list()

for (pop in pop_groups) {

  #Extract the Normalization data for each population
  dge.data_Normalization_pop <- dge.data_Normalization[, sample.description_data$Pop == pop]
  #Extract sample description data for each population
  sample.description_data_pop <- sample.description_data %>% filter(Pop == pop)
  #redesign the matrix with correct # column for each population
  design_pop <- model.matrix(~Vern, data = sample.description_data_pop)
  rownames(design_pop) <- sample.description_data_pop$samples
  #using matrix to find out the Normalization dispersions for each population
  dge.data_Normalization_dispersions_pop <- estimateGLMCommonDisp(dge.data_Normalization_pop, design_pop, verbose = TRUE)
  
  #Fit the model for each population dispersion data
  fit_pop <- glmFit(dge.data_Normalization_dispersions_pop, design_pop)
  # Conduct likelihood ratio test for each population
  gt.lrt_pop <- glmLRT(fit_pop, coef = "Vernv2")
  
  # Summarize the results for each population (up / down regulation)
  result_v0v2_pop <- summary(decideTestsDGE(gt.lrt_pop, p = 0.01))
  description <- "v0v2 comparison for population: " 
  results_list[[pop]] <- list(
  Description = paste(description, pop, sep=""),
  Results = result_v0v2_pop)
  }

# Print or return results
print(results_list)

```
Loop for each population (v1 vs v2)

| Population | Down | NotSig | Up   |
|------------|------|--------|------|
| bhr        | 468  | 29029  | 486  |
| ihl        | 374  | 29304  | 305  |
| kc         | 19   | 29778  | 186  |
| lv         | 1220 | 28555  | 208  |
| sq         | 195  | 29605  | 183  |
| tm         | 0    | 29940  | 43   |
| wl         | 108  | 29689  | 186  |
| yo         | 87   | 29465  | 431  |


1. create a new reference for v1
```{r}
sample.description_data_v1_reference <- data%>%
  mutate(Pop=factor(Pop), 
         Vern=factor(Vern,levels = c("v1","v0", "v2","i0","i1","i2"))) # setting the levels in this way makes "v1" the reference  

sample.description_data_v1_reference
```

2. loop for comparison
```{r}
pop_groups <- unique(sample.description_data_v1_reference$Pop)
results_list <- list()

for (pop in pop_groups) {

  #Extract the Normalization data for each population
  dge.data_Normalization_pop <- dge.data_Normalization[, sample.description_data_v1_reference$Pop == pop]
  #Extract sample description data for each population
  sample.description_data_pop <- sample.description_data_v1_reference %>% filter(Pop == pop)
  #redesign the matrix with correct # column for each population
  design_pop <- model.matrix(~Vern, data = sample.description_data_pop)
  rownames(design_pop) <- sample.description_data_pop$samples
  #using matrix to find out the Normalization dispersions for each population
  dge.data_Normalization_dispersions_pop <- estimateGLMCommonDisp(dge.data_Normalization_pop, design_pop, verbose = TRUE)
  
  #Fit the model for each population dispersion data
  fit_pop <- glmFit(dge.data_Normalization_dispersions_pop, design_pop)
  # Conduct likelihood ratio test for each population
  gt.lrt_pop <- glmLRT(fit_pop, coef = "Vernv2")
  # Summarize the results for each population (up / down regulation)
  result_v1v2_pop <- summary(decideTestsDGE(gt.lrt_pop, p = 0.01))
  description <- "v1v2 comparison for population: " 
  results_list[[pop]] <- list(
    Description = paste(description, pop, sep=""),
    Results = result_v1v2_pop)
   }

# Print or return results
print(results_list)
```

